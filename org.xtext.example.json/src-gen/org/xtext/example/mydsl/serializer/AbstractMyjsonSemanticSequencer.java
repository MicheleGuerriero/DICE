/*
 * generated by Xtext
 */
package org.xtext.example.mydsl.serializer;

import _12.AttributesType;
import _12.CapabilitiesType;
import _12.CapabilitiesType1;
import _12.CapabilityDefinitionsType;
import _12.ConstraintsType;
import _12.ConstraintsType1;
import _12.DerivedFromType2;
import _12.InputParametersType;
import _12.InputParametersType1;
import _12.InstanceStateType;
import _12.InterfacesType;
import _12.InterfacesType1;
import _12.NodeOperationType;
import _12.OutputParametersType;
import _12.OutputParametersType1;
import _12.PlanModelReferenceType;
import _12.PlanModelType;
import _12.PlanType;
import _12.PoliciesType;
import _12.PoliciesType1;
import _12.PropertiesDefinitionType;
import _12.PropertiesType;
import _12.PropertiesType1;
import _12.PropertyConstraintsType;
import _12.PropertyConstraintsType1;
import _12.PropertyMappingsType;
import _12.RelationshipConstraintType;
import _12.RelationshipConstraintsType;
import _12.RelationshipOperationType;
import _12.RequirementDefinitionsType;
import _12.RequirementsType;
import _12.RequirementsType1;
import _12.SourceElementType;
import _12.SourceInterfacesType;
import _12.TAttribute;
import _12.TBoundaryDefinitions;
import _12.TCapability;
import _12.TCapabilityDefinition;
import _12.TCapabilityRef;
import _12.TCondition;
import _12.TConstraint;
import _12.TDeploymentArtifact;
import _12.TDeploymentArtifacts;
import _12.TDocumentation;
import _12.TExportedInterface;
import _12.TExportedOperation;
import _12.TInputTemplate;
import _12.TInterface;
import _12.TNodeTemplate;
import _12.TNodeType;
import _12.TOperation;
import _12.TOutputTemplate;
import _12.TParameter;
import _12.TPlan;
import _12.TPlans;
import _12.TPolicy;
import _12.TProperty;
import _12.TPropertyConstraint;
import _12.TPropertyMapping;
import _12.TRelationshipTemplate;
import _12.TRelationshipType;
import _12.TRequirement;
import _12.TRequirementDefinition;
import _12.TRequirementRef;
import _12.TServiceTemplate;
import _12.TTag;
import _12.TTags;
import _12.TTopologyElementInstanceStates;
import _12.TTopologyTemplate;
import _12.TargetElementType;
import _12.TargetInterfacesType;
import _12.TimportTemplate;
import _12.ValidSourceType;
import _12.ValidTargetType;
import _12._12Package;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.MyjsonGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractMyjsonSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyjsonGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == _12Package.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case _12Package.ATTRIBUTES_TYPE:
				sequence_AttributesType(context, (AttributesType) semanticObject); 
				return; 
			case _12Package.CAPABILITIES_TYPE:
				sequence_CapabilitiesType(context, (CapabilitiesType) semanticObject); 
				return; 
			case _12Package.CAPABILITIES_TYPE1:
				sequence_CapabilitiesType1(context, (CapabilitiesType1) semanticObject); 
				return; 
			case _12Package.CAPABILITY_DEFINITIONS_TYPE:
				sequence_CapabilityDefinitionsType(context, (CapabilityDefinitionsType) semanticObject); 
				return; 
			case _12Package.CONSTRAINTS_TYPE:
				sequence_ConstraintsType(context, (ConstraintsType) semanticObject); 
				return; 
			case _12Package.CONSTRAINTS_TYPE1:
				sequence_ConstraintsType1(context, (ConstraintsType1) semanticObject); 
				return; 
			case _12Package.DERIVED_FROM_TYPE2:
				sequence_DerivedFromType2(context, (DerivedFromType2) semanticObject); 
				return; 
			case _12Package.INPUT_PARAMETERS_TYPE:
				sequence_InputParametersType(context, (InputParametersType) semanticObject); 
				return; 
			case _12Package.INPUT_PARAMETERS_TYPE1:
				sequence_InputParametersType1(context, (InputParametersType1) semanticObject); 
				return; 
			case _12Package.INSTANCE_STATE_TYPE:
				sequence_InstanceStateType(context, (InstanceStateType) semanticObject); 
				return; 
			case _12Package.INTERFACES_TYPE:
				sequence_InterfacesType(context, (InterfacesType) semanticObject); 
				return; 
			case _12Package.INTERFACES_TYPE1:
				sequence_InterfacesType1(context, (InterfacesType1) semanticObject); 
				return; 
			case _12Package.NODE_OPERATION_TYPE:
				sequence_NodeOperationType(context, (NodeOperationType) semanticObject); 
				return; 
			case _12Package.OUTPUT_PARAMETERS_TYPE:
				sequence_OutputParametersType(context, (OutputParametersType) semanticObject); 
				return; 
			case _12Package.OUTPUT_PARAMETERS_TYPE1:
				sequence_OutputParametersType1(context, (OutputParametersType1) semanticObject); 
				return; 
			case _12Package.PLAN_MODEL_REFERENCE_TYPE:
				sequence_PlanModelReferenceType(context, (PlanModelReferenceType) semanticObject); 
				return; 
			case _12Package.PLAN_MODEL_TYPE:
				sequence_PlanModelType(context, (PlanModelType) semanticObject); 
				return; 
			case _12Package.PLAN_TYPE:
				sequence_PlanType(context, (PlanType) semanticObject); 
				return; 
			case _12Package.POLICIES_TYPE:
				sequence_PoliciesType(context, (PoliciesType) semanticObject); 
				return; 
			case _12Package.POLICIES_TYPE1:
				sequence_PoliciesType1(context, (PoliciesType1) semanticObject); 
				return; 
			case _12Package.PROPERTIES_DEFINITION_TYPE:
				sequence_PropertiesDefinitionType(context, (PropertiesDefinitionType) semanticObject); 
				return; 
			case _12Package.PROPERTIES_TYPE:
				sequence_PropertiesType(context, (PropertiesType) semanticObject); 
				return; 
			case _12Package.PROPERTIES_TYPE1:
				sequence_PropertiesType1(context, (PropertiesType1) semanticObject); 
				return; 
			case _12Package.PROPERTY_CONSTRAINTS_TYPE:
				sequence_PropertyConstraintsType(context, (PropertyConstraintsType) semanticObject); 
				return; 
			case _12Package.PROPERTY_CONSTRAINTS_TYPE1:
				sequence_PropertyConstraintsType1(context, (PropertyConstraintsType1) semanticObject); 
				return; 
			case _12Package.PROPERTY_MAPPINGS_TYPE:
				sequence_PropertyMappingsType(context, (PropertyMappingsType) semanticObject); 
				return; 
			case _12Package.RELATIONSHIP_CONSTRAINT_TYPE:
				sequence_RelationshipConstraintType(context, (RelationshipConstraintType) semanticObject); 
				return; 
			case _12Package.RELATIONSHIP_CONSTRAINTS_TYPE:
				sequence_RelationshipConstraintsType(context, (RelationshipConstraintsType) semanticObject); 
				return; 
			case _12Package.RELATIONSHIP_OPERATION_TYPE:
				sequence_RelationshipOperationType(context, (RelationshipOperationType) semanticObject); 
				return; 
			case _12Package.REQUIREMENT_DEFINITIONS_TYPE:
				sequence_RequirementDefinitionsType(context, (RequirementDefinitionsType) semanticObject); 
				return; 
			case _12Package.REQUIREMENTS_TYPE:
				sequence_RequirementsType(context, (RequirementsType) semanticObject); 
				return; 
			case _12Package.REQUIREMENTS_TYPE1:
				sequence_RequirementsType1(context, (RequirementsType1) semanticObject); 
				return; 
			case _12Package.SOURCE_ELEMENT_TYPE:
				sequence_SourceElementType(context, (SourceElementType) semanticObject); 
				return; 
			case _12Package.SOURCE_INTERFACES_TYPE:
				sequence_SourceInterfacesType(context, (SourceInterfacesType) semanticObject); 
				return; 
			case _12Package.TATTRIBUTE:
				sequence_TAttribute(context, (TAttribute) semanticObject); 
				return; 
			case _12Package.TBOUNDARY_DEFINITIONS:
				sequence_TBoundaryDefinitions(context, (TBoundaryDefinitions) semanticObject); 
				return; 
			case _12Package.TCAPABILITY:
				sequence_TCapability(context, (TCapability) semanticObject); 
				return; 
			case _12Package.TCAPABILITY_DEFINITION:
				sequence_TCapabilityDefinition(context, (TCapabilityDefinition) semanticObject); 
				return; 
			case _12Package.TCAPABILITY_REF:
				sequence_TCapabilityRef(context, (TCapabilityRef) semanticObject); 
				return; 
			case _12Package.TCONDITION:
				sequence_TCondition(context, (TCondition) semanticObject); 
				return; 
			case _12Package.TCONSTRAINT:
				sequence_TConstraint_Impl(context, (TConstraint) semanticObject); 
				return; 
			case _12Package.TDEPLOYMENT_ARTIFACT:
				sequence_TDeploymentArtifact(context, (TDeploymentArtifact) semanticObject); 
				return; 
			case _12Package.TDEPLOYMENT_ARTIFACTS:
				sequence_TDeploymentArtifacts(context, (TDeploymentArtifacts) semanticObject); 
				return; 
			case _12Package.TDOCUMENTATION:
				sequence_TDocumentation(context, (TDocumentation) semanticObject); 
				return; 
			case _12Package.TEXPORTED_INTERFACE:
				sequence_TExportedInterface(context, (TExportedInterface) semanticObject); 
				return; 
			case _12Package.TEXPORTED_OPERATION:
				sequence_TExportedOperation(context, (TExportedOperation) semanticObject); 
				return; 
			case _12Package.TINPUT_TEMPLATE:
				sequence_TInputTemplate(context, (TInputTemplate) semanticObject); 
				return; 
			case _12Package.TINTERFACE:
				sequence_TInterface(context, (TInterface) semanticObject); 
				return; 
			case _12Package.TNODE_TEMPLATE:
				sequence_TNodeTemplate(context, (TNodeTemplate) semanticObject); 
				return; 
			case _12Package.TNODE_TYPE:
				sequence_TNodeType(context, (TNodeType) semanticObject); 
				return; 
			case _12Package.TOPERATION:
				sequence_TOperation(context, (TOperation) semanticObject); 
				return; 
			case _12Package.TOUTPUT_TEMPLATE:
				sequence_TOutputTemplate(context, (TOutputTemplate) semanticObject); 
				return; 
			case _12Package.TPARAMETER:
				sequence_TParameter(context, (TParameter) semanticObject); 
				return; 
			case _12Package.TPLAN:
				sequence_TPlan(context, (TPlan) semanticObject); 
				return; 
			case _12Package.TPLANS:
				sequence_TPlans(context, (TPlans) semanticObject); 
				return; 
			case _12Package.TPOLICY:
				sequence_TPolicy(context, (TPolicy) semanticObject); 
				return; 
			case _12Package.TPROPERTY:
				sequence_TProperty(context, (TProperty) semanticObject); 
				return; 
			case _12Package.TPROPERTY_CONSTRAINT:
				sequence_TPropertyConstraint(context, (TPropertyConstraint) semanticObject); 
				return; 
			case _12Package.TPROPERTY_MAPPING:
				sequence_TPropertyMapping(context, (TPropertyMapping) semanticObject); 
				return; 
			case _12Package.TRELATIONSHIP_TEMPLATE:
				sequence_TRelationshipTemplate(context, (TRelationshipTemplate) semanticObject); 
				return; 
			case _12Package.TRELATIONSHIP_TYPE:
				sequence_TRelationshipType(context, (TRelationshipType) semanticObject); 
				return; 
			case _12Package.TREQUIREMENT:
				sequence_TRequirement(context, (TRequirement) semanticObject); 
				return; 
			case _12Package.TREQUIREMENT_DEFINITION:
				sequence_TRequirementDefinition(context, (TRequirementDefinition) semanticObject); 
				return; 
			case _12Package.TREQUIREMENT_REF:
				sequence_TRequirementRef(context, (TRequirementRef) semanticObject); 
				return; 
			case _12Package.TSERVICE_TEMPLATE:
				sequence_TServiceTemplate(context, (TServiceTemplate) semanticObject); 
				return; 
			case _12Package.TTAG:
				sequence_TTag(context, (TTag) semanticObject); 
				return; 
			case _12Package.TTAGS:
				sequence_TTags(context, (TTags) semanticObject); 
				return; 
			case _12Package.TTOPOLOGY_ELEMENT_INSTANCE_STATES:
				sequence_TTopologyElementInstanceStates(context, (TTopologyElementInstanceStates) semanticObject); 
				return; 
			case _12Package.TTOPOLOGY_TEMPLATE:
				sequence_TTopologyTemplate(context, (TTopologyTemplate) semanticObject); 
				return; 
			case _12Package.TARGET_ELEMENT_TYPE:
				sequence_TargetElementType(context, (TargetElementType) semanticObject); 
				return; 
			case _12Package.TARGET_INTERFACES_TYPE:
				sequence_TargetInterfacesType(context, (TargetInterfacesType) semanticObject); 
				return; 
			case _12Package.TIMPORT_TEMPLATE:
				sequence_TimportTemplate(context, (TimportTemplate) semanticObject); 
				return; 
			case _12Package.VALID_SOURCE_TYPE:
				sequence_ValidSourceType(context, (ValidSourceType) semanticObject); 
				return; 
			case _12Package.VALID_TARGET_TYPE:
				sequence_ValidTargetType(context, (ValidTargetType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (attribute+=TAttribute attribute+=TAttribute*)
	 */
	protected void sequence_AttributesType(EObject context, AttributesType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (capability+=TCapabilityRef capability+=TCapabilityRef*)
	 */
	protected void sequence_CapabilitiesType1(EObject context, CapabilitiesType1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (capability+=TCapability capability+=TCapability*)
	 */
	protected void sequence_CapabilitiesType(EObject context, CapabilitiesType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (capabilityDefinition+=TCapabilityDefinition capabilityDefinition+=TCapabilityDefinition*)
	 */
	protected void sequence_CapabilityDefinitionsType(EObject context, CapabilityDefinitionsType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (constraint+=TConstraint constraint+=TConstraint*)
	 */
	protected void sequence_ConstraintsType1(EObject context, ConstraintsType1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (constraint+=TConstraint constraint+=TConstraint*)
	 */
	protected void sequence_ConstraintsType(EObject context, ConstraintsType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     typeRef=QName
	 */
	protected void sequence_DerivedFromType2(EObject context, DerivedFromType2 semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.DERIVED_FROM_TYPE2__TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.DERIVED_FROM_TYPE2__TYPE_REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDerivedFromType2Access().getTypeRefQNameParserRuleCall_3_0(), semanticObject.getTypeRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (inputParameter+=TParameter inputParameter+=TParameter*)
	 */
	protected void sequence_InputParametersType1(EObject context, InputParametersType1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (inputParameter+=TParameter inputParameter+=TParameter*)
	 */
	protected void sequence_InputParametersType(EObject context, InputParametersType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     state=AnyURI
	 */
	protected void sequence_InstanceStateType(EObject context, InstanceStateType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.INSTANCE_STATE_TYPE__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.INSTANCE_STATE_TYPE__STATE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInstanceStateTypeAccess().getStateAnyURIParserRuleCall_3_0(), semanticObject.getState());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (interface+=TExportedInterface interface+=TExportedInterface*)
	 */
	protected void sequence_InterfacesType1(EObject context, InterfacesType1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (interface+=TInterface interface+=TInterface*)
	 */
	protected void sequence_InterfacesType(EObject context, InterfacesType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (interfaceName=AnyURI nodeRef=IDREF operationName=NCName)
	 */
	protected void sequence_NodeOperationType(EObject context, NodeOperationType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.NODE_OPERATION_TYPE__INTERFACE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.NODE_OPERATION_TYPE__INTERFACE_NAME));
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.NODE_OPERATION_TYPE__NODE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.NODE_OPERATION_TYPE__NODE_REF));
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.NODE_OPERATION_TYPE__OPERATION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.NODE_OPERATION_TYPE__OPERATION_NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNodeOperationTypeAccess().getInterfaceNameAnyURIParserRuleCall_3_0(), semanticObject.getInterfaceName());
		feeder.accept(grammarAccess.getNodeOperationTypeAccess().getNodeRefIDREFParserRuleCall_5_0(), semanticObject.getNodeRef());
		feeder.accept(grammarAccess.getNodeOperationTypeAccess().getOperationNameNCNameParserRuleCall_7_0(), semanticObject.getOperationName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (outputParameter+=TParameter outputParameter+=TParameter*)
	 */
	protected void sequence_OutputParametersType1(EObject context, OutputParametersType1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (outputParameter+=TParameter outputParameter+=TParameter*)
	 */
	protected void sequence_OutputParametersType(EObject context, OutputParametersType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     reference=AnyURI
	 */
	protected void sequence_PlanModelReferenceType(EObject context, PlanModelReferenceType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.PLAN_MODEL_REFERENCE_TYPE__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.PLAN_MODEL_REFERENCE_TYPE__REFERENCE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPlanModelReferenceTypeAccess().getReferenceAnyURIParserRuleCall_3_0(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {PlanModelType}
	 */
	protected void sequence_PlanModelType(EObject context, PlanModelType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     planRef=IDREF
	 */
	protected void sequence_PlanType(EObject context, PlanType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.PLAN_TYPE__PLAN_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.PLAN_TYPE__PLAN_REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPlanTypeAccess().getPlanRefIDREFParserRuleCall_3_0(), semanticObject.getPlanRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (policy+=TPolicy policy+=TPolicy*)
	 */
	protected void sequence_PoliciesType1(EObject context, PoliciesType1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (policy+=TPolicy policy+=TPolicy*)
	 */
	protected void sequence_PoliciesType(EObject context, PoliciesType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (element=QName? type=QName? hasSomProperties=PropertiesType?)
	 */
	protected void sequence_PropertiesDefinitionType(EObject context, PropertiesDefinitionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (propertyMappings=PropertyMappingsType?)
	 */
	protected void sequence_PropertiesType1(EObject context, PropertiesType1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (property+=TProperty property+=TProperty*)
	 */
	protected void sequence_PropertiesType(EObject context, PropertiesType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (propertyConstraint+=TPropertyConstraint propertyConstraint+=TPropertyConstraint*)
	 */
	protected void sequence_PropertyConstraintsType1(EObject context, PropertyConstraintsType1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (propertyConstraint+=TPropertyConstraint propertyConstraint+=TPropertyConstraint*)
	 */
	protected void sequence_PropertyConstraintsType(EObject context, PropertyConstraintsType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (propertyMapping+=TPropertyMapping propertyMapping+=TPropertyMapping*)
	 */
	protected void sequence_PropertyMappingsType(EObject context, PropertyMappingsType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     constraintType=AnyURI
	 */
	protected void sequence_RelationshipConstraintType(EObject context, RelationshipConstraintType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (relationshipConstraint+=RelationshipConstraintType relationshipConstraint+=RelationshipConstraintType*)
	 */
	protected void sequence_RelationshipConstraintsType(EObject context, RelationshipConstraintsType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (interfaceName=AnyURI operationName=NCName relationshipRef=IDREF)
	 */
	protected void sequence_RelationshipOperationType(EObject context, RelationshipOperationType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.RELATIONSHIP_OPERATION_TYPE__INTERFACE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.RELATIONSHIP_OPERATION_TYPE__INTERFACE_NAME));
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.RELATIONSHIP_OPERATION_TYPE__OPERATION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.RELATIONSHIP_OPERATION_TYPE__OPERATION_NAME));
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.RELATIONSHIP_OPERATION_TYPE__RELATIONSHIP_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.RELATIONSHIP_OPERATION_TYPE__RELATIONSHIP_REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRelationshipOperationTypeAccess().getInterfaceNameAnyURIParserRuleCall_3_0(), semanticObject.getInterfaceName());
		feeder.accept(grammarAccess.getRelationshipOperationTypeAccess().getOperationNameNCNameParserRuleCall_5_0(), semanticObject.getOperationName());
		feeder.accept(grammarAccess.getRelationshipOperationTypeAccess().getRelationshipRefIDREFParserRuleCall_7_0(), semanticObject.getRelationshipRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (requirementDefinition+=TRequirementDefinition requirementDefinition+=TRequirementDefinition*)
	 */
	protected void sequence_RequirementDefinitionsType(EObject context, RequirementDefinitionsType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (requirement+=TRequirementRef requirement+=TRequirementRef*)
	 */
	protected void sequence_RequirementsType1(EObject context, RequirementsType1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (requirement+=TRequirement requirement+=TRequirement*)
	 */
	protected void sequence_RequirementsType(EObject context, RequirementsType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ref=IDREF
	 */
	protected void sequence_SourceElementType(EObject context, SourceElementType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.SOURCE_ELEMENT_TYPE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.SOURCE_ELEMENT_TYPE__REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSourceElementTypeAccess().getRefIDREFParserRuleCall_3_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (interface+=TInterface interface+=TInterface*)
	 */
	protected void sequence_SourceInterfacesType(EObject context, SourceInterfacesType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=String0? value=String0?)
	 */
	protected void sequence_TAttribute(EObject context, TAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         properties=PropertiesType1? 
	 *         propertyConstraints=PropertyConstraintsType1? 
	 *         requirements=RequirementsType1? 
	 *         capabilities=CapabilitiesType1? 
	 *         policies=PoliciesType1? 
	 *         interfaces=InterfacesType1?
	 *     )
	 */
	protected void sequence_TBoundaryDefinitions(EObject context, TBoundaryDefinitions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         capabilityType=QName 
	 *         lowerBound=Int0? 
	 *         name=String0 
	 *         upperBound=UpperBoundType? 
	 *         (documentation+=TDocumentation documentation+=TDocumentation*)? 
	 *         constraints=ConstraintsType?
	 *     )
	 */
	protected void sequence_TCapabilityDefinition(EObject context, TCapabilityDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=String0? ref=IDREF)
	 */
	protected void sequence_TCapabilityRef(EObject context, TCapabilityRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         id=ID0 
	 *         type=EString 
	 *         name=String0 
	 *         (documentation+=TDocumentation documentation+=TDocumentation*)? 
	 *         properties=PropertiesType? 
	 *         propertyConstraints=PropertyConstraintsType? 
	 *         attributes=AttributesType? 
	 *         nodeHasInterface=TInterface? 
	 *         (nodeHasRelations+=TRelationshipType nodeHasRelations+=TRelationshipType*)?
	 *     )
	 */
	protected void sequence_TCapability(EObject context, TCapability semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expressionLanguage=AnyURI
	 */
	protected void sequence_TCondition(EObject context, TCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     constraintType=AnyURI
	 */
	protected void sequence_TConstraint_Impl(EObject context, TConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (artifactRef=QName? artifactType=QName name=String0 (documentation+=TDocumentation documentation+=TDocumentation*)?)
	 */
	protected void sequence_TDeploymentArtifact(EObject context, TDeploymentArtifact semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (deploymentArtifact+=TDeploymentArtifact deploymentArtifact+=TDeploymentArtifact*)
	 */
	protected void sequence_TDeploymentArtifacts(EObject context, TDeploymentArtifacts semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (lang=LangType? source=AnyURI?)
	 */
	protected void sequence_TDocumentation(EObject context, TDocumentation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=AnyURI operation+=TExportedOperation operation+=TExportedOperation*)
	 */
	protected void sequence_TExportedInterface(EObject context, TExportedInterface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=NCName nodeOperation=NodeOperationType? relationshipOperation=RelationshipOperationType? plan=PlanType?)
	 */
	protected void sequence_TExportedOperation(EObject context, TExportedOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=STRING (value+=STRING value+=STRING*)? description=STRING?)
	 */
	protected void sequence_TInputTemplate(EObject context, TInputTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=AnyURI operation+=TOperation operation+=TOperation*)
	 */
	protected void sequence_TInterface(EObject context, TInterface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         id=STRING 
	 *         type=STRING 
	 *         maxInstances=MaxInstancesType? 
	 *         minInstances=Int0? 
	 *         instances=STRING? 
	 *         (documentation+=TDocumentation documentation+=TDocumentation*)? 
	 *         properties=PropertiesType? 
	 *         propertyConstraints=PropertyConstraintsType? 
	 *         attributes=AttributesType? 
	 *         nodeHasInterface=TInterface? 
	 *         (nodeHasRelations+=TRelationshipType nodeHasRelations+=TRelationshipType*)? 
	 *         requirements=RequirementsType? 
	 *         capabilities=CapabilitiesType? 
	 *         policies=PoliciesType? 
	 *         deploymentArtifacts=TDeploymentArtifacts?
	 *     )
	 */
	protected void sequence_TNodeTemplate(EObject context, TNodeTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         abstract=TBoolean? 
	 *         final=TBoolean? 
	 *         name=NCName 
	 *         targetNamespace=AnyURI? 
	 *         (documentation+=TDocumentation documentation+=TDocumentation*)? 
	 *         tags=TTags? 
	 *         derivedFrom=DerivedFromType2? 
	 *         propertiesDefinition=PropertiesDefinitionType? 
	 *         requirementDefinitions=RequirementDefinitionsType? 
	 *         capabilityDefinitions=CapabilityDefinitionsType? 
	 *         instanceStates=TTopologyElementInstanceStates? 
	 *         interfaces=InterfacesType?
	 *     )
	 */
	protected void sequence_TNodeType(EObject context, TNodeType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=NCName 
	 *         scriptPath=EString? 
	 *         (documentation+=TDocumentation documentation+=TDocumentation*)? 
	 *         inputParameters=InputParametersType? 
	 *         outputParameters=OutputParametersType?
	 *     )
	 */
	protected void sequence_TOperation(EObject context, TOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=STRING (value+=STRING value+=STRING*)?)
	 */
	protected void sequence_TOutputTemplate(EObject context, TOutputTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=String0 required=TBoolean? type=String0)
	 */
	protected void sequence_TParameter(EObject context, TParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         id=ID0 
	 *         name=String0? 
	 *         planLanguage=AnyURI 
	 *         planType=AnyURI 
	 *         (documentation+=TDocumentation documentation+=TDocumentation*)? 
	 *         precondition=TCondition? 
	 *         inputParameters=InputParametersType1? 
	 *         outputParameters=OutputParametersType1? 
	 *         planModel=PlanModelType? 
	 *         planModelReference=PlanModelReferenceType?
	 *     )
	 */
	protected void sequence_TPlan(EObject context, TPlan semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (targetNamespace=AnyURI? plan+=TPlan plan+=TPlan*)
	 */
	protected void sequence_TPlans(EObject context, TPlans semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=String0? policyRef=QName? policyType=QName (documentation+=TDocumentation documentation+=TDocumentation*)?)
	 */
	protected void sequence_TPolicy(EObject context, TPolicy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (constraintType=AnyURI property=String0)
	 */
	protected void sequence_TPropertyConstraint(EObject context, TPropertyConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (serviceTemplatePropertyRef=String0 targetObjectRef=IDREF targetPropertyRef=String0)
	 */
	protected void sequence_TPropertyMapping(EObject context, TPropertyMapping semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.TPROPERTY_MAPPING__SERVICE_TEMPLATE_PROPERTY_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.TPROPERTY_MAPPING__SERVICE_TEMPLATE_PROPERTY_REF));
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.TPROPERTY_MAPPING__TARGET_OBJECT_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.TPROPERTY_MAPPING__TARGET_OBJECT_REF));
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.TPROPERTY_MAPPING__TARGET_PROPERTY_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.TPROPERTY_MAPPING__TARGET_PROPERTY_REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTPropertyMappingAccess().getServiceTemplatePropertyRefString0ParserRuleCall_3_0(), semanticObject.getServiceTemplatePropertyRef());
		feeder.accept(grammarAccess.getTPropertyMappingAccess().getTargetObjectRefIDREFParserRuleCall_5_0(), semanticObject.getTargetObjectRef());
		feeder.accept(grammarAccess.getTPropertyMappingAccess().getTargetPropertyRefString0ParserRuleCall_7_0(), semanticObject.getTargetPropertyRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=STRING (value+=STRING value+=STRING*)? (defaultValue+=STRING defaultValue+=STRING*)?)
	 */
	protected void sequence_TProperty(EObject context, TProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         id=ID0 
	 *         type=EString 
	 *         name=String0? 
	 *         (documentation+=TDocumentation documentation+=TDocumentation*)? 
	 *         properties=PropertiesType? 
	 *         propertyConstraints=PropertyConstraintsType? 
	 *         attributes=AttributesType? 
	 *         nodeHasInterface=TInterface? 
	 *         (nodeHasRelations+=TRelationshipType nodeHasRelations+=TRelationshipType*)? 
	 *         sourceElement=SourceElementType 
	 *         targetElement=TargetElementType 
	 *         relationshipConstraints=RelationshipConstraintsType? 
	 *         usesRelationType=TRelationshipType?
	 *     )
	 */
	protected void sequence_TRelationshipTemplate(EObject context, TRelationshipTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         targetNamespace=STRING? 
	 *         abstract=TBoolean? 
	 *         final=TBoolean? 
	 *         (documentation+=TDocumentation documentation+=TDocumentation*)? 
	 *         tags=TTags? 
	 *         derivedFrom=DerivedFromType2? 
	 *         propertiesDefinition=PropertiesDefinitionType? 
	 *         instanceStates=TTopologyElementInstanceStates? 
	 *         sourceInterfaces=SourceInterfacesType? 
	 *         targetInterfaces=TargetInterfacesType? 
	 *         validSource=ValidSourceType? 
	 *         validTarget=ValidTargetType?
	 *     )
	 */
	protected void sequence_TRelationshipType(EObject context, TRelationshipType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         lowerBound=Int0? 
	 *         name=String0 
	 *         requirementType=QName 
	 *         upperBound=UpperBoundType1? 
	 *         (documentation+=TDocumentation documentation+=TDocumentation*)? 
	 *         constraints=ConstraintsType1?
	 *     )
	 */
	protected void sequence_TRequirementDefinition(EObject context, TRequirementDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=String0? ref=IDREF)
	 */
	protected void sequence_TRequirementRef(EObject context, TRequirementRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         id=ID0 
	 *         type=EString 
	 *         name=String0 
	 *         (documentation+=TDocumentation documentation+=TDocumentation*)? 
	 *         properties=PropertiesType? 
	 *         propertyConstraints=PropertyConstraintsType? 
	 *         attributes=AttributesType? 
	 *         nodeHasInterface=TInterface? 
	 *         (nodeHasRelations+=TRelationshipType nodeHasRelations+=TRelationshipType*)?
	 *     )
	 */
	protected void sequence_TRequirement(EObject context, TRequirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         id=STRING 
	 *         name=STRING? 
	 *         hasImports=TimportTemplate? 
	 *         substitutableNodeType=QName? 
	 *         targetNamespace=AnyURI? 
	 *         (documentation+=TDocumentation documentation+=TDocumentation*)? 
	 *         tags=TTags? 
	 *         boundaryDefinitions=TBoundaryDefinitions? 
	 *         topologyTemplate=TTopologyTemplate 
	 *         plans=TPlans? 
	 *         (hasNodeType+=TNodeType hasNodeType+=TNodeType*)? 
	 *         (hasRelationship+=TRelationshipType hasRelationship+=TRelationshipType*)?
	 *     )
	 */
	protected void sequence_TServiceTemplate(EObject context, TServiceTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=String0 value=String0)
	 */
	protected void sequence_TTag(EObject context, TTag semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.TTAG__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.TTAG__NAME));
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.TTAG__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.TTAG__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTTagAccess().getNameString0ParserRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTTagAccess().getValueString0ParserRuleCall_5_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (tag+=TTag tag+=TTag*)
	 */
	protected void sequence_TTags(EObject context, TTags semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (instanceState+=InstanceStateType instanceState+=InstanceStateType*)
	 */
	protected void sequence_TTopologyElementInstanceStates(EObject context, TTopologyElementInstanceStates semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (documentation+=TDocumentation documentation+=TDocumentation*)? 
	 *         (hasInputs+=TInputTemplate hasInputs+=TInputTemplate*)? 
	 *         (nodeTemplate+=TNodeTemplate nodeTemplate+=TNodeTemplate*)? 
	 *         (relationshipTemplate+=TRelationshipTemplate relationshipTemplate+=TRelationshipTemplate*)? 
	 *         (hasoutPuts+=TOutputTemplate hasoutPuts+=TOutputTemplate*)?
	 *     )
	 */
	protected void sequence_TTopologyTemplate(EObject context, TTopologyTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ref=IDREF
	 */
	protected void sequence_TargetElementType(EObject context, TargetElementType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.TARGET_ELEMENT_TYPE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.TARGET_ELEMENT_TYPE__REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTargetElementTypeAccess().getRefIDREFParserRuleCall_3_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (interface+=TInterface interface+=TInterface*)
	 */
	protected void sequence_TargetInterfacesType(EObject context, TargetInterfacesType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value+=EString value+=EString*)
	 */
	protected void sequence_TimportTemplate(EObject context, TimportTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     typeRef=QName
	 */
	protected void sequence_ValidSourceType(EObject context, ValidSourceType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.VALID_SOURCE_TYPE__TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.VALID_SOURCE_TYPE__TYPE_REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getValidSourceTypeAccess().getTypeRefQNameParserRuleCall_3_0(), semanticObject.getTypeRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     typeRef=QName
	 */
	protected void sequence_ValidTargetType(EObject context, ValidTargetType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, _12Package.Literals.VALID_TARGET_TYPE__TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, _12Package.Literals.VALID_TARGET_TYPE__TYPE_REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getValidTargetTypeAccess().getTypeRefQNameParserRuleCall_3_0(), semanticObject.getTypeRef());
		feeder.finish();
	}
}
